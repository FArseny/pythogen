# ==============================================================================
#
# Client (HTTP-client)
#
# This file was generated by a code generator.
# Don't make changes to it manually.
#
# ==============================================================================

# jinja2: lstrip_blocks: "True"
# mypy: ignore-errors

from __future__ import annotations

import abc
from datetime import datetime

from httpx import Timeout


try:
    from typing import Literal
except ImportError:
    from typing_extensions import Literal

import logging
from functools import wraps
from typing import IO
from typing import Any
from typing import Callable
from typing import Dict
from typing import List
from typing import Optional
from typing import Tuple
from typing import Union
from typing import cast

import httpx
from jaeger_client import Tracer
from jaeger_client.span import Span
from opentracing.ext import tags
from opentracing.propagation import Format
from prometheus_client import Counter
from prometheus_client import Histogram
from pydantic import BaseModel
from pydantic import Field


tracer: Tracer


class TracerNotConfigured(Exception):
    pass


class TracerConfig(BaseModel):
    app_name: str
    host: str
    port: int
    propagation: str
    jaeger_enabled: bool


class BaseTracerIntegration(abc.ABC):
    def __init__(self, tracer: Optional[Tracer] = None):
        self.tracer = tracer

    @abc.abstractmethod
    def get_tracing_http_headers(self) -> Dict[str, str]:
        ...

    @abc.abstractmethod
    def get_current_trace_id(self) -> Optional[str]:
        ...

    @abc.abstractmethod
    def get_tracer(self) -> Tracer:
        ...

    @abc.abstractmethod
    def get_current_span(self) -> Optional[Span]:
        ...


class DefaultTracerIntegration(BaseTracerIntegration):
    def get_tracing_http_headers(self) -> Dict[str, str]:
        tracer = self.get_tracer()
        span = self.get_current_span()
        if not span:
            return {}
        span.set_tag(tags.SPAN_KIND, tags.SPAN_KIND_RPC_CLIENT)
        headers: Dict[str, str] = {}
        tracer.inject(span, Format.HTTP_HEADERS, headers)
        return headers

    def get_current_trace_id(self) -> Optional[str]:
        span = self.get_current_span()
        trace_id = span.trace_id if span else None
        return '{:x}'.format(trace_id) if trace_id else None

    def get_tracer(self) -> Tracer:
        if not self.tracer:
            raise TracerNotConfigured('configure tracing first')
        return self.tracer

    def get_current_span(self) -> Optional[Span]:
        tracer = self.get_tracer()
        active = tracer.scope_manager.active
        return cast(Span, active.span) if active else None


def tracing(f: Callable[..., Any]) -> Callable[..., Any]:
    @wraps(f)
    async def wrapper(self: Any, *args: Any, **kwargs: Any) -> Any:
        if not self.tracer_integration:
            return await f(self, *args, **kwargs)

        db_query = kwargs.get('query', None)
        current_tags = {}
        if db_query is not None:
            current_tags[tags.DATABASE_TYPE] = 'postgres'
            current_tags[tags.DATABASE_STATEMENT] = db_query

        tracer = self.tracer_integration.get_tracer()
        span = tracer.start_span(
            operation_name=f.__qualname__, child_of=self.tracer_integration.get_current_span(), tags=current_tags
        )
        scope = tracer.scope_manager.activate(span, True)
        try:
            result = await f(self, *args, **kwargs)
        except Exception as exp:
            span.set_tag(tags.ERROR, True)
            span.set_tag('error.message', str(exp))
            raise exp
        finally:
            scope.close()
        return result

    return wrapper


# backward compatibility for httpx<0.18.2
try:
    DEFAULT_AUTH = httpx.USE_CLIENT_DEFAULT
except AttributeError:
    DEFAULT_AUTH = None


class BaseMetricsIntegration(abc.ABC):
    def __init__(
        self,
        client_response_time_histogram: Optional[Histogram] = None,
        client_non_http_errors_counter: Optional[Counter] = None,
    ):
        self._client_response_time_histogram = client_response_time_histogram
        self._client_non_http_errors_counter = client_non_http_errors_counter

    @abc.abstractmethod
    def on_request_error(self, error: Exception, http_method: str, http_target: str) -> None:
        ...

    @abc.abstractmethod
    def on_request_success(self, response, http_method: str, http_target: str) -> None:
        ...


class DefaultMetricsIntegration(BaseMetricsIntegration):
    def on_request_error(self, client_name: str, error: Exception, http_method: str, http_target: str) -> None:
        self._client_non_http_errors_counter.labels(
            client_name=client_name,
            http_method=http_method,
            http_target=http_target,
            exception=error.__class__.__name__,
        ).inc(1)
        raise error

    def on_request_success(self, client_name: str, response, http_method: str, http_target: str) -> None:
        self._client_response_time_histogram.labels(
            client_name=client_name,
            http_method=http_method,
            http_target=http_target,
            http_status_code=response.status_code,
        ).observe(response.elapsed.total_seconds())


FileContent = Union[IO[str], IO[bytes], str, bytes]
FileTypes = Union[
    # file (or text)
    FileContent,
    # (filename, file (or text))
    Tuple[Optional[str], FileContent],
    # (filename, file (or text), content_type)
    Tuple[Optional[str], FileContent, Optional[str]],
]


class EmptyBody(BaseModel):
    status_code: int
    text: str


class LogsuserintothesystemResponse200(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    text: Optional[str] = None


class ReturnspetinventoriesbystatusResponse200(BaseModel):
    """
    None
    """

    # required ---

    # optional ---


class FindsPetsbytagsResponse200(BaseModel):
    """
    None
    """

    # required ---

    # optional ---


class FindsPetsbystatusResponse200(BaseModel):
    """
    None
    """

    # required ---

    # optional ---


class ApiResponse(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    code: Optional[int] = None
    type: Optional[str] = None
    message: Optional[str] = None


class Tag(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    id: Optional[int] = None
    name: Optional[str] = None


class Category(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    id: Optional[int] = None
    name: Optional[str] = None


class Pet(BaseModel):
    """
    None
    """

    # required ---
    name: str
    photoUrls: List[str]

    # optional ---
    id: Optional[int] = None
    category: Optional[Category] = None
    tags: Optional[List[Tag]] = None
    status: Optional[Literal['available', 'pending', 'sold']] = Field(description="pet status in the store")


class User(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    id: Optional[int] = None
    username: Optional[str] = None
    firstName: Optional[str] = None
    lastName: Optional[str] = None
    email: Optional[str] = None
    password: Optional[str] = None
    phone: Optional[str] = None
    userStatus: Optional[int] = Field(description="User Status")


class Address(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    street: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    zip: Optional[str] = None


class Customer(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    id: Optional[int] = None
    username: Optional[str] = None
    address: Optional[List[Address]] = None


class Order(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    id: Optional[int] = None
    petId: Optional[int] = None
    quantity: Optional[int] = None
    shipDate: Optional[datetime] = None
    status: Optional[Literal['placed', 'approved', 'delivered']] = Field(description="Order Status")
    complete: Optional[bool] = None


class BasicAuth(BaseModel):
    username: str
    password: str


class Client:
    def __init__(
        self,
        base_url: str,
        timeout: int = 5,
        client: Optional[httpx.AsyncClient] = None,
        headers: Dict[str, str] = None,
        tracer_integration: Optional[BaseTracerIntegration] = None,
        metrics_integration: Optional[BaseMetricsIntegration] = None,
    ):
        self.client = client or httpx.AsyncClient(timeout=Timeout(timeout))
        self.base_url = base_url
        self.headers = headers or {}
        self.tracer_integration = tracer_integration
        self.metrics_integration = metrics_integration

    @tracing
    async def findPetsByStatus(
        self,
        status: Optional[Literal['available', 'pending', 'sold']] = None,
        auth: Optional[BasicAuth] = None,
    ) -> Union[List[Pet], EmptyBody]:
        url = self._get_url(f'/pet/findByStatus')

        params = {}
        if status is not None:
            params['status'] = status

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.get(url, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "get", "/pet/findByStatus")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "get", "/pet/findByStatus")

        if response.status_code == 200:
            return [Pet.parse_obj(item) for item in response.json()]

        if response.status_code == 400:
            client_name = ""
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    @tracing
    async def findPetsByTags(
        self,
        tags: Optional[List[str]] = None,
        auth: Optional[BasicAuth] = None,
    ) -> Union[List[Pet], EmptyBody]:
        url = self._get_url(f'/pet/findByTags')

        params = {}
        if tags is not None:
            params['tags'] = tags

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.get(url, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "get", "/pet/findByTags")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "get", "/pet/findByTags")

        if response.status_code == 200:
            return [Pet.parse_obj(item) for item in response.json()]

        if response.status_code == 400:
            client_name = ""
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    @tracing
    async def getPetById(
        self,
        petId: int,
        auth: Optional[BasicAuth] = None,
    ) -> Union[Pet, EmptyBody, EmptyBody]:
        url = self._get_url(f'/pet/{petId}')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.get(url, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "get", "/pet/:petId")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "get", "/pet/:petId")

        if response.status_code == 200:
            return Pet.parse_obj(response.json())

        if response.status_code == 400:
            client_name = ""
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 404:
            client_name = ""
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    @tracing
    async def getInventory(
        self,
        auth: Optional[BasicAuth] = None,
    ) -> Optional[ReturnspetinventoriesbystatusResponse200]:
        url = self._get_url(f'/store/inventory')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.get(url, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "get", "/store/inventory")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "get", "/store/inventory")

        if response.status_code == 200:
            return ReturnspetinventoriesbystatusResponse200.parse_obj(response.json())

    @tracing
    async def getOrderById(
        self,
        orderId: int,
        auth: Optional[BasicAuth] = None,
    ) -> Union[Order, EmptyBody, EmptyBody]:
        url = self._get_url(f'/store/order/{orderId}')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.get(url, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "get", "/store/order/:orderId")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "get", "/store/order/:orderId")

        if response.status_code == 200:
            return Order.parse_obj(response.json())

        if response.status_code == 400:
            client_name = ""
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 404:
            client_name = ""
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    @tracing
    async def loginUser(
        self,
        username: Optional[str] = None,
        password: Optional[str] = None,
        auth: Optional[BasicAuth] = None,
    ) -> Union[LogsuserintothesystemResponse200, EmptyBody]:
        url = self._get_url(f'/user/login')

        params = {}
        if username is not None:
            params['username'] = username
        if password is not None:
            params['password'] = password

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.get(url, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "get", "/user/login")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "get", "/user/login")

        if response.status_code == 200:
            return LogsuserintothesystemResponse200(text=response.text)

        if response.status_code == 400:
            client_name = ""
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    @tracing
    async def logoutUser(
        self,
        auth: Optional[BasicAuth] = None,
    ) -> None:
        url = self._get_url(f'/user/logout')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.get(url, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "get", "/user/logout")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "get", "/user/logout")

    @tracing
    async def getUserByName(
        self,
        username: str,
        auth: Optional[BasicAuth] = None,
    ) -> Union[User, EmptyBody, EmptyBody]:
        url = self._get_url(f'/user/{username}')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.get(url, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "get", "/user/:username")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "get", "/user/:username")

        if response.status_code == 200:
            return User.parse_obj(response.json())

        if response.status_code == 400:
            client_name = ""
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 404:
            client_name = ""
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    @tracing
    async def addPet(
        self,
        body: Optional[Union[Pet, Dict[str, Any]]] = None,
        auth: Optional[BasicAuth] = None,
    ) -> Union[Pet, EmptyBody]:
        url = self._get_url(f'/pet')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, Pet):
            json = body.dict()
        else:
            json = None

        try:
            response = await self.client.post(url, json=json, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "post", "/pet")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "post", "/pet")

        if response.status_code == 200:
            return Pet.parse_obj(response.json())

        if response.status_code == 405:
            client_name = ""
            method = "post"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    @tracing
    async def updatePetWithForm(
        self,
        petId: int,
        name: Optional[str] = None,
        status: Optional[str] = None,
        auth: Optional[BasicAuth] = None,
    ) -> Optional[EmptyBody]:
        url = self._get_url(f'/pet/{petId}')

        params = {}
        if name is not None:
            params['name'] = name
        if status is not None:
            params['status'] = status

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.post(url, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "post", "/pet/:petId")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "post", "/pet/:petId")

        if response.status_code == 405:
            client_name = ""
            method = "post"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    @tracing
    async def uploadFile(
        self,
        petId: int,
        body: Optional[Union[bytes, Dict[str, Any]]] = None,
        additional_metadata: Optional[str] = None,
        auth: Optional[BasicAuth] = None,
    ) -> Optional[ApiResponse]:
        url = self._get_url(f'/pet/{petId}/uploadImage')

        params = {}
        if additional_metadata is not None:
            params['additionalMetadata'] = additional_metadata

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, bytes):
            json = body.dict()
        else:
            json = None

        try:
            response = await self.client.post(url, json=json, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "post", "/pet/:petId/uploadImage")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "post", "/pet/:petId/uploadImage")

        if response.status_code == 200:
            return ApiResponse.parse_obj(response.json())

    @tracing
    async def placeOrder(
        self,
        body: Optional[Union[Order, Dict[str, Any]]] = None,
        auth: Optional[BasicAuth] = None,
    ) -> Union[Order, EmptyBody]:
        url = self._get_url(f'/store/order')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, Order):
            json = body.dict()
        else:
            json = None

        try:
            response = await self.client.post(url, json=json, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "post", "/store/order")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "post", "/store/order")

        if response.status_code == 200:
            return Order.parse_obj(response.json())

        if response.status_code == 405:
            client_name = ""
            method = "post"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    @tracing
    async def createUser(
        self,
        body: Optional[Union[User, Dict[str, Any]]] = None,
        auth: Optional[BasicAuth] = None,
    ) -> None:
        url = self._get_url(f'/user')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, User):
            json = body.dict()
        else:
            json = None

        try:
            response = await self.client.post(url, json=json, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "post", "/user")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "post", "/user")

    @tracing
    async def createUsersWithListInput(
        self,
        body: Optional[Union[List[User], Dict[str, Any]]] = None,
        auth: Optional[BasicAuth] = None,
    ) -> Optional[User]:
        url = self._get_url(f'/user/createWithList')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, List[User]):
            json = body.dict()
        else:
            json = None

        try:
            response = await self.client.post(url, json=json, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "post", "/user/createWithList")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "post", "/user/createWithList")

        if response.status_code == 200:
            return User.parse_obj(response.json())

    @tracing
    async def updatePet(
        self,
        body: Optional[Union[Pet, Dict[str, Any]]] = None,
        auth: Optional[BasicAuth] = None,
    ) -> Union[Pet, EmptyBody, EmptyBody, EmptyBody]:
        url = self._get_url(f'/pet')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, Pet):
            json = body.dict()
        else:
            json = None

        try:
            response = await self.client.put(url, json=json, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "put", "/pet")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "put", "/pet")

        if response.status_code == 200:
            return Pet.parse_obj(response.json())

        if response.status_code == 400:
            client_name = ""
            method = "put"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 404:
            client_name = ""
            method = "put"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 405:
            client_name = ""
            method = "put"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    @tracing
    async def updateUser(
        self,
        username: str,
        body: Optional[Union[User, Dict[str, Any]]] = None,
        auth: Optional[BasicAuth] = None,
    ) -> None:
        url = self._get_url(f'/user/{username}')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, User):
            json = body.dict()
        else:
            json = None

        try:
            response = await self.client.put(url, json=json, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "put", "/user/:username")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "put", "/user/:username")

    @tracing
    async def deletePet(
        self,
        petId: int,
        api_key: Optional[str] = None,
        auth: Optional[BasicAuth] = None,
    ) -> Optional[EmptyBody]:
        url = self._get_url(f'/pet/{petId}')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)
        if api_key is not None:
            headers_['api_key'] = api_key

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.delete(url, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "delete", "/pet/:petId")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "delete", "/pet/:petId")

        if response.status_code == 400:
            client_name = ""
            method = "delete"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    @tracing
    async def deleteOrder(
        self,
        orderId: int,
        auth: Optional[BasicAuth] = None,
    ) -> Union[EmptyBody, EmptyBody]:
        url = self._get_url(f'/store/order/{orderId}')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.delete(url, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "delete", "/store/order/:orderId")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "delete", "/store/order/:orderId")

        if response.status_code == 400:
            client_name = ""
            method = "delete"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 404:
            client_name = ""
            method = "delete"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    @tracing
    async def deleteUser(
        self,
        username: str,
        auth: Optional[BasicAuth] = None,
    ) -> Union[EmptyBody, EmptyBody]:
        url = self._get_url(f'/user/{username}')

        params = {}

        headers_ = self.headers.copy()

        if self.tracer_integration:
            self.add_tracing_data_to_headers(headers_)

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.delete(url, headers=headers_, params=params, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                self.metrics_integration.on_request_error(exc, "", "delete", "/user/:username")
            raise exc

        if self.metrics_integration:
            self.metrics_integration.on_request_success(response, "", "delete", "/user/:username")

        if response.status_code == 400:
            client_name = ""
            method = "delete"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 404:
            client_name = ""
            method = "delete"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            self.log_error(client_name, method, url, params, content, headers_)

            return EmptyBody(status_code=response.status_code, text=response.text)

    async def close(self) -> None:
        await self.client.aclose()

    def _get_url(self, path: str) -> str:
        return f'{self.base_url}{path}'

    def log_extra(self, **kwargs: Any) -> Dict[str, Any]:
        return {'extra': {'props': {'data': kwargs}}}

    def log_error(self, client_name: str, method, url: str, params, content, headers) -> None:
        msg = f"request error"
        msg += f" | client={client_name}"
        msg += f" | method={method}"
        msg += f" | url={url}"
        msg += f" | params={params}"
        msg += f" | content={content}"
        msg += f" | headers={headers}"

        logging.error(
            msg,
            **self.log_extra(
                client=client_name,
                method=method,
                content=content,
                url=url,
                params=params,
            ),
        )

    def add_tracing_data_to_headers(self, headers_: Dict[str, str]) -> None:
        tracing_headers = self.tracer_integration.get_tracing_http_headers()
        headers_.update(tracing_headers)
        trace_id = self.tracer_integration.get_current_trace_id() or ''
        headers_['x-trace-id'] = trace_id


LogsuserintothesystemResponse200.update_forward_refs()
ReturnspetinventoriesbystatusResponse200.update_forward_refs()
FindsPetsbytagsResponse200.update_forward_refs()
FindsPetsbystatusResponse200.update_forward_refs()
ApiResponse.update_forward_refs()
Tag.update_forward_refs()
Category.update_forward_refs()
Pet.update_forward_refs()
User.update_forward_refs()
Address.update_forward_refs()
Customer.update_forward_refs()
Order.update_forward_refs()
